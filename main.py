# main.py
import os
import asyncio
import random
import logging
from datetime import datetime, timedelta

import discord
from discord import app_commands
from discord.ext import tasks

# ---------- „É≠„Ç∞ ----------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("matchbot")

# ---------- Áí∞Â¢ÉÂ§âÊï∞ ----------
TOKEN = os.environ["DISCORD_TOKEN"]
GUILD_ID = int(os.environ["GUILD_ID"])
ADMIN_ID = int(os.environ["ADMIN_ID"])
# optional channels
RANKING_CHANNEL_ID = int(os.environ.get("RANKING_CHANNEL_ID") or 0)
JUDGE_CHANNEL_ID = int(os.environ.get("JUDGE_CHANNEL_ID") or 0)

# Ëá™ÂãïÊâøË™ç„Çø„Ç§„É†ÔºàÊïóËÄÖÊâøË™çÂæÖ„Å°„ÅÆÊôÇÈñìÔºâ
AUTO_APPROVE_SECONDS = 15 * 60  # 15ÂàÜ

# /„Éû„ÉÉ„ÉÅÂ∏åÊúõ „ÅÆ‰øùÊåÅÊôÇÈñì
MATCH_WISH_TTL = 5 * 60  # 5ÂàÜ

# ÊäΩÈÅ∏ÂæÖÊ©üÔºàÁü≠ÊôÇÈñìÔºâ: 5Áßí „Å´Ë®≠ÂÆöÔºà‰ªïÊßò„Å´Âêà„Çè„Åõ„Å¶Ôºâ
DRAW_WAIT_SECONDS = 5

# ÂãùËÄÖÁî≥ÂëäÂæå„ÅÆÊïóËÄÖÊâøË™ç„Éú„Çø„É≥„ÅÆÊúâÂäπÊúüÈôêÔºà5ÂàÜÔºâ
RESULT_APPROVE_TIMEOUT = 5 * 60

# ---------- Bot „Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó ----------
intents = discord.Intents.default()
intents.members = True  # „É¶„Éº„Ç∂ÊÉÖÂ†±„ÅåÂøÖË¶ÅÔºà„É≠„Éº„É´‰ªò‰∏é„Éª„Éã„ÉÉ„ÇØÂ§âÊõ¥Ôºâ
intents.message_content = False  # ‰∏çË¶Å
bot = discord.Client(intents=intents)
tree = app_commands.CommandTree(bot)

# ---------- „Éá„Éº„ÇøÊßãÈÄ†Ôºà„É°„É¢„É™ÂÜÖÔºâ ----------
# user_data: user_id -> {"pt": int}
user_data: dict[int, dict] = {}

# matching: user_id -> opponent_id  (for established matches)
matching: dict[int, int] = {}

# pending_applications: applicant_id -> (opponent_id, origin_channel_id, msg_id)
# For direct match requests (not random); kept for compatibility (but Random variant uses /„Éû„ÉÉ„ÉÅÂ∏åÊúõ)
pending_applications: dict[int, dict] = {}

# hope_list: user_id -> timestamp (when they issued /„Éû„ÉÉ„ÉÅÂ∏åÊúõ)
hope_list: dict[int, float] = {}

# For tracking per-user TTL removal tasks (so we can cancel when user withdraws)
hope_timers: dict[int, asyncio.Task] = {}

# draw_in_progress flag and draw lock to prevent concurrent draws
draw_lock = asyncio.Lock()
draw_task: asyncio.Task | None = None

# result_pending: (winner_id, loser_id) -> {"message": msg, "task": auto_approve_task}
result_pending: dict[tuple[int, int], dict] = {}

# role mapping (for display icon and role name)
# Note: Random variant uses simplified rank (no challenge). Icons used for nickname formatting.
rank_definitions = [
    (0, 4, "Beginner", "üî∞"),
    (5, 9, "Silver", "ü•à"),
    (10, 14, "Gold", "ü•á"),
    (15, 19, "Master", "‚öîÔ∏è"),
    (20, 24, "GroundMaster", "ü™Ω"),
    (25, 99999, "Challenger", "üòà"),
]

# internal rank ranges for rank-difference logic
internal_rank_ranges = {
    1: range(0, 5),    # 0-4
    2: range(5, 10),   # 5-9
    3: range(10, 15),  # 10-14
    4: range(15, 20),  # 15-19
    5: range(20, 25),  # 20-24
    6: range(25, 10000), # 25+
}

# ---------- „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞ ----------

def get_user_pt(user_id: int) -> int:
    return user_data.get(user_id, {}).get("pt", 0)

def set_user_pt(user_id: int, pt: int):
    if pt < 0:
        pt = 0
    user_data.setdefault(user_id, {})["pt"] = pt

def get_rank_info_by_pt(pt: int):
    for start, end, role_name, icon in rank_definitions:
        if isinstance(start, int) and isinstance(end, int):
            if pt >= start and pt <= end:
                return role_name, icon
    # fallback
    return "Beginner", "üî∞"

def get_role_for_pt(guild: discord.Guild, pt: int):
    role_name, _ = get_rank_info_by_pt(pt)
    return discord.utils.get(guild.roles, name=role_name)

def get_icon_for_pt(pt: int) -> str:
    _, icon = get_rank_info_by_pt(pt)
    return icon

def get_internal_rank(pt: int) -> int:
    for r, rng in internal_rank_ranges.items():
        if pt in rng:
            return r
    return 1

# PTË®àÁÆóÔºà„É©„É≥„ÇØÂ∑Æ„Å´„Çà„ÇãË®àÁÆó„Çí internal_rank Â∑Æ„ÅßÊâ±„ÅÜÔºâ
def calculate_pt_change(winner_pt: int, loser_pt: int):
    # internal ranks
    wr = get_internal_rank(winner_pt)
    lr = get_internal_rank(loser_pt)
    diff = lr - wr  # positive if loser is higher internal rank than winner
    # But we need to compute by perspective of winner vs loser
    # Use the rules:
    # same rank: winner +1, loser -1
    # 1 rank up opponent: winner +2, loser -1
    # 2 rank up opponent: winner +3, loser -1
    # 1 rank down opponent: winner +1, loser -2
    # 2 rank down opponent: winner +1, loser -3
    rank_diff = get_internal_rank(loser_pt) - get_internal_rank(winner_pt)
    # if loser is higher internal rank than winner: rank_diff > 0
    if rank_diff == 0:
        w_delta = 1
        l_delta = -1
    elif rank_diff == 1:
        w_delta = 2
        l_delta = -1
    elif rank_diff == 2:
        w_delta = 3
        l_delta = -1
    elif rank_diff == -1:
        w_delta = 1
        l_delta = -2
    elif rank_diff == -2:
        w_delta = 1
        l_delta = -3
    else:
        # rank diff >=3 or <= -3 shouldn't have been allowed to match
        w_delta = 1
        l_delta = -1
    return w_delta, l_delta

def apply_rank_edge_cases_after_loss(pt_before: int) -> int:
    # handle downgrade when the lost pt is in special ranges (3,4 -> 2 etc)
    # per spec exceptions (for Random variant we kept same exceptions as main):
    if pt_before in (3,4):
        return 2
    if pt_before in (8,9):
        return 7
    if pt_before in (13,14):
        return 12
    if pt_before in (18,19):
        return 17
    if pt_before in (23,24):
        return 22
    # else return current pt (they will be adjusted by deltas)
    return None

# nickname formatting: original_name (if possible) + " {icon} {pt}pt"
def compose_display_nick(base_name: str, icon: str, pt: int):
    return f"{base_name} {icon} {pt}pt"

async def safe_update_nick(member: discord.Member, new_nick: str):
    try:
        # If the bot can't change nick (e.g., target is owner/higher role), ignore gracefully
        await member.edit(nick=new_nick)
    except Exception as e:
        logger.debug(f"Failed to update nick for {member}: {e}")

async def update_member_display(guild: discord.Guild, user_id: int):
    member = guild.get_member(user_id)
    if not member:
        return
    pt = get_user_pt(user_id)
    icon = get_icon_for_pt(pt)
    # prefer original username without previous appended tag: strip trailing " {icon} {pt}pt" patterns
    base = member.name
    # If member.nick exists and includes pattern, remove it
    name_to_use = member.name
    # Compose new nick
    new_nick = compose_display_nick(name_to_use, icon, pt)
    # Limit nick length to 32
    if len(new_nick) > 32:
        new_nick = new_nick[:32]
    await safe_update_nick(member, new_nick)
    # Update roles: remove other rank roles, add correct one
    role_for_pt = get_role_for_pt(guild, pt)
    if role_for_pt:
        try:
            # Remove all rank roles then add the correct one
            rank_role_names = [r[2] for r in rank_definitions]
            to_remove = [r for r in guild.roles if r.name in rank_role_names and r in member.roles and r != role_for_pt]
            if to_remove:
                await member.remove_roles(*to_remove, reason="Rank sync")
            if role_for_pt not in member.roles:
                await member.add_roles(role_for_pt, reason="Rank sync")
        except Exception as e:
            logger.debug(f"Failed to update roles for {member}: {e}")

# ---------- „Éû„ÉÉ„ÉÅ/ÊäΩÈÅ∏„É≠„Ç∏„ÉÉ„ÇØ ----------

async def start_draw_if_needed(guild: discord.Guild, origin_channel: discord.abc.Messageable):
    """
    Called when hope_list changes. If enough participants exist and no draw in progress,
    start a draw that waits DRAW_WAIT_SECONDS then attempts to randomly pair entries respecting rank constraints.
    """
    global draw_task
    async with draw_lock:
        if draw_task and not draw_task.done():
            return  # already drawing
        # if fewer than 2 participants, nothing to do
        alive = list(hope_list.keys())
        if len(alive) < 2:
            return
        # launch draw task
        draw_task = asyncio.create_task(draw_and_pair(guild, origin_channel))

async def draw_and_pair(guild: discord.Guild, origin_channel: discord.abc.Messageable):
    """
    Wait DRAW_WAIT_SECONDS allowing more joiners, then attempt to pair randomly.
    Respect rank-difference constraint: internal rank difference must be < 3.
    Matched pairs are removed from hope_list and added to matching.
    Matched users are notified publicly in the channel where their /„Éû„ÉÉ„ÉÅÂ∏åÊúõ was issued (origin_channel).
    """
    await asyncio.sleep(DRAW_WAIT_SECONDS)
    # snapshot of current hope_list keys (note: hope_list entries may change concurrently)
    participants = list(hope_list.keys())
    random.shuffle(participants)
    paired = set()
    pairs = []
    # greedy: try to pair in random order with first compatible partner
    for i, a in enumerate(participants):
        if a in paired:
            continue
        for b in participants[i+1:]:
            if b in paired:
                continue
            # check internal rank diff
            ar = get_internal_rank(get_user_pt(a))
            br = get_internal_rank(get_user_pt(b))
            if abs(ar - br) >= 3:
                continue
            # also check special-challenge-like restrictions on pt (the limited-match states)
            a_pt = get_user_pt(a)
            b_pt = get_user_pt(b)
            def challenge_ok(my_pt, other_pt):
                if my_pt in (3,8,13,18,23):
                    return other_pt >= my_pt
                if my_pt in (4,9,14,19,24):
                    return (other_pt >= my_pt) or (other_pt == my_pt - 1)
                return True
            if not challenge_ok(a_pt, b_pt) or not challenge_ok(b_pt, a_pt):
                continue
            # pair them
            paired.add(a); paired.add(b)
            pairs.append((a, b))
            break
    # For each pair, register matching and notify both
    for a, b in pairs:
        # remove from hope_list and cancel timers
        hope_list.pop(a, None)
        t = hope_timers.pop(a, None)
        if t and not t.done():
            t.cancel()
        hope_list.pop(b, None)
        t = hope_timers.pop(b, None)
        if t and not t.done():
            t.cancel()
        # register matching (both directions)
        matching[a] = b
        matching[b] = a
        # notify publicly in origin_channel
        try:
            await origin_channel.send(f"<@{a}> „Å® <@{b}> „ÅÆ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÅåÊàêÁ´ã„Åó„Åæ„Åó„Åü„ÄÇË©¶ÂêàÂæå„ÄÅÂãùËÄÖ„Åå /ÁµêÊûúÂ†±Âëä „ÇíË°å„Å™„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        except Exception:
            logger.debug("Failed to send match-formed message to origin channel.")
    # leftover participants are kept in hope_list (per spec), so do nothing else
    return

async def schedule_remove_wish(user_id: int):
    """
    Called when a user issues /„Éû„ÉÉ„ÉÅÂ∏åÊúõ. Wait MATCH_WISH_TTL and then remove them if still present.
    We keep a handle so we can cancel if they withdraw earlier or are matched.
    """
    await asyncio.sleep(MATCH_WISH_TTL)
    if user_id in hope_list:
        hope_list.pop(user_id, None)
    # clear timer entry
    hope_timers.pop(user_id, None)

# ---------- Views (Buttons) ----------

class ApproveMatchView(discord.ui.View):
    """
    For manual direct match request: allows the target to approve.
    Only the target can press Approve.
    """
    def __init__(self, applicant_id:int, opponent_id:int, origin_channel_id:int):
        super().__init__(timeout=None)
        self.applicant_id = applicant_id
        self.opponent_id = opponent_id
        self.origin_channel_id = origin_channel_id

    @discord.ui.button(label="ÊâøË™ç", style=discord.ButtonStyle.success)
    async def approve(self, interaction: discord.Interaction, button: discord.ui.Button):
        # only the opponent can approve
        if interaction.user.id != self.opponent_id:
            await interaction.response.send_message("ÊâøË™ç„Åß„Åç„Çã„ÅÆ„ÅØÁî≥Ë´ã„Åï„Çå„ÅüÁõ∏Êâã„ÅÆ„Åø„Åß„Åô„ÄÇ", ephemeral=True)
            return
        # make matching
        matching[self.applicant_id] = self.opponent_id
        matching[self.opponent_id] = self.applicant_id
        guild = interaction.guild
        ch = guild.get_channel(self.origin_channel_id) if self.origin_channel_id else interaction.channel
        if ch:
            await ch.send(f"<@{self.applicant_id}> „Å® <@{self.opponent_id}> „ÅÆ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÅåÊàêÁ´ã„Åó„Åæ„Åó„Åü„ÄÇË©¶ÂêàÂæå„ÄÅÂãùËÄÖ„Åå /ÁµêÊûúÂ†±Âëä „ÇíË°å„Å™„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
        await interaction.response.send_message("ÊâøË™ç„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)
        self.stop()

class CancelExistingMatchView(discord.ui.View):
    """
    If someone tries to apply to a user who is already in a match, prompt to cancel existing match.
    Only applicant (the one seeing the prompt) can press the cancel button to cancel existing match pair.
    """
    def __init__(self, existing_a:int, existing_b:int):
        super().__init__(timeout=60)
        self.existing_a = existing_a
        self.existing_b = existing_b

    @discord.ui.button(label="Âèñ„ÇäÊ∂à„Åô", style=discord.ButtonStyle.danger)
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        # allow the one who sees it (the applicant) to cancel
        a = self.existing_a
        b = self.existing_b
        if matching.get(a) == b:
            matching.pop(a, None)
            matching.pop(b, None)
            await interaction.response.send_message(f"<@{a}> „Å® <@{b}> „ÅÆ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÅØËß£Èô§„Åï„Çå„Åæ„Åó„Åü„ÄÇ", ephemeral=False)
        else:
            await interaction.response.send_message("Ë©≤ÂΩì„ÅÆ„Éû„ÉÉ„ÉÅ„ÅØÊó¢„Å´Ëß£Èô§„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ", ephemeral=True)
        self.stop()

class ResultApproveView(discord.ui.View):
    """
    View for loser to approve or dispute the result. Only the loser can interact.
    """
    def __init__(self, winner_id:int, loser_id:int):
        super().__init__(timeout=RESULT_APPROVE_TIMEOUT)
        self.winner_id = winner_id
        self.loser_id = loser_id
        self.processed = False

    async def on_timeout(self):
        # auto-approve if not processed
        if not self.processed:
            key = (self.winner_id, self.loser_id)
            if key in result_pending:
                info = result_pending.pop(key, None)
                # call approved handler (channel from info)
                channel = info.get("channel")
                try:
                    await handle_approved_result(self.winner_id, self.loser_id, channel)
                except Exception:
                    logger.exception("auto-approve failed")

    @discord.ui.button(label="ÊâøË™ç", style=discord.ButtonStyle.success)
    async def approve(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.loser_id:
            await interaction.response.send_message("„Åì„Çå„ÅØ„ÅÇ„Å™„Åü„ÅÆË©¶Âêà„Åß„ÅØ„Å™„ÅÑ„Çà„ÅÜ„Åß„Åô„ÄÇ", ephemeral=True)
            return
        if self.processed:
            await interaction.response.send_message("Êó¢„Å´Âá¶ÁêÜÊ∏à„Åø„Åß„Åô„ÄÇ", ephemeral=True)
            return
        self.processed = True
        await interaction.response.edit_message(content="ÊâøË™ç„Åï„Çå„Åæ„Åó„Åü„ÄÇÁµêÊûú„ÇíÂèçÊò†„Åó„Åæ„Åô„ÄÇ", view=None)
        await handle_approved_result(self.winner_id, self.loser_id, interaction.channel)

    @discord.ui.button(label="Áï∞Ë≠∞", style=discord.ButtonStyle.danger)
    async def dispute(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.loser_id:
            await interaction.response.send_message("„Åì„Çå„ÅØ„ÅÇ„Å™„Åü„ÅÆË©¶Âêà„Åß„ÅØ„Å™„ÅÑ„Çà„ÅÜ„Åß„Åô„ÄÇ", ephemeral=True)
            return
        if self.processed:
            await interaction.response.send_message("Êó¢„Å´Âá¶ÁêÜÊ∏à„Åø„Åß„Åô„ÄÇ", ephemeral=True)
            return
        self.processed = True
        await interaction.response.edit_message(content="Áï∞Ë≠∞„ÅåÁî≥Á´ã„Å¶„Çâ„Çå„Åæ„Åó„Åü„ÄÇÂØ©Âà§„ÉÅ„É£„É≥„Éç„É´„Å∏ÈÄöÁü•„Åó„Åæ„Åô„ÄÇ", view=None)
        # notify judge channel
        guild = interaction.guild
        judge_ch = guild.get_channel(JUDGE_CHANNEL_ID) if JUDGE_CHANNEL_ID else None
        if judge_ch:
            await judge_ch.send(f"‚öñÔ∏è ÂØ©Ë≠∞‰æùÈ†º: <@{self.winner_id}> vs <@{self.loser_id}> „Å´Áï∞Ë≠∞„ÅåÂá∫„Åæ„Åó„Åü„ÄÇ\n„Åì„ÅÆ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÅØÁÑ°ÂäπÊâ±„ÅÑ„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÂØ©Ë≠∞ÁµêÊûú„Çí <@{ADMIN_ID}> „Å´„ÅîÂ†±Âëä„Åè„Å†„Åï„ÅÑ„ÄÇ")
        # remove matching
        matching.pop(self.winner_id, None)
        matching.pop(self.loser_id, None)
        # clear pending
        result_pending.pop((self.winner_id, self.loser_id), None)

# ---------- ÁµêÊûúÂá¶ÁêÜ ----------

def is_registered_match(a: int, b: int) -> bool:
    return matching.get(a) == b and matching.get(b) == a

async def handle_approved_result(winner_id:int, loser_id:int, channel: discord.abc.Messageable):
    # validate registration
    if not is_registered_match(winner_id, loser_id):
        await channel.send("„Åì„ÅÆ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÅØÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åæ„Åö„ÅØ„Éû„ÉÉ„ÉÅ„É≥„Ç∞Áî≥Ë´ã„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ")
        return

    winner_pt_before = get_user_pt(winner_id)
    loser_pt_before = get_user_pt(loser_id)
    w_delta, l_delta = calculate_pt_change(winner_pt_before, loser_pt_before)

    # apply loss exception downgrade if losing pt is one of special cases BEFORE applying delta?
    # The spec says: on loss, revert to specific values; but general logic applied as per spec: implement loss downgrade override.
    # We'll first compute provisional loser_pt_after = loser_pt_before + l_delta, then if loser_pt_before in exception set, set to provided floor.
    provisional_loser_after = loser_pt_before + l_delta
    # check exception
    special = apply_rank_edge_cases_after_loss(provisional_loser_after)
    if special is not None:
        loser_new = special
    else:
        loser_new = provisional_loser_after
        if loser_new < 0:
            loser_new = 0

    winner_new = winner_pt_before + w_delta
    if winner_new < 0:
        winner_new = 0

    # write back
    set_user_pt(winner_id, winner_new)
    set_user_pt(loser_id, loser_new)

    # reflect changes to guild members (all guilds bot is in)
    for g in bot.guilds:
        await update_member_display(g, winner_id)
        await update_member_display(g, loser_id)

    # remove matching
    matching.pop(winner_id, None)
    matching.pop(loser_id, None)
    # remove pending result
    result_pending.pop((winner_id, loser_id), None)

    # send result message
    delta_w = winner_new - winner_pt_before
    delta_l = loser_new - loser_pt_before
    await channel.send(f"‚úÖ <@{winner_id}> „Å´ +{delta_w}ptÔºè<@{loser_id}> „Å´ {delta_l}pt „ÅÆÂèçÊò†„ÇíË°å„ÅÑ„Åæ„Åó„Åü„ÄÇ")

# ---------- „Ç≥„Éû„É≥„ÉâÁæ§ ----------

@tree.command(name="„Éû„ÉÉ„ÉÅÂ∏åÊúõ", description="„É©„É≥„ÉÄ„É†„Éû„ÉÉ„ÉÅ„Å´„Ç®„É≥„Éà„É™„Éº„Åó„Åæ„Åô„ÄÇÁõ∏ÊâãÊåáÂÆö„ÅØ‰∏çË¶Å„Åß„Åô„ÄÇ")
async def cmd_match_wish(interaction: discord.Interaction):
    user = interaction.user
    uid = user.id
    # if already in match, cannot enter
    if uid in matching:
        opp = matching[uid]
        await interaction.response.send_message(f"<@{opp}> „Å®„ÅÆË©¶Âêà„ÅåÊó¢„Å´ÊàêÁ´ã‰∏≠„Åß„Åô„ÄÇË©¶Âêà„ÇíÁµÇ„Åà„Å¶„Åã„ÇâÂÜçÂ∫¶Áî≥Ë´ã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", ephemeral=True)
        return
    # if already in hope list
    if uid in hope_list:
        await interaction.response.send_message("Êó¢„Å´„Éû„ÉÉ„ÉÅÂ∏åÊúõ„ÅåÂá∫„Å¶„ÅÑ„Åæ„Åô„ÄÇ", ephemeral=True)
        return
    # add to hope_list
    hope_list[uid] = asyncio.get_event_loop().time()
    # schedule removal after TTL
    t = asyncio.create_task(schedule_remove_wish(uid))
    hope_timers[uid] = t
    # if there's at least one other waiting, start draw
    # notify only the user
    await interaction.response.send_message("„Éû„ÉÉ„ÉÅ„É≥„Ç∞Â∏åÊúõ„ÇíÂèó„Åë‰ªò„Åë„Åæ„Åó„Åü„ÄÇ „Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÅåÊàêÁ´ã„Åó„ÅüÂ†¥Âêà„ÄÅ„Åù„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Å´„Å¶ÈÄöÁü•„Åï„Çå„Åæ„Åô„ÄÇ", ephemeral=True)
    # start draw on the channel where command executed
    await start_draw_if_needed(interaction.guild, interaction.channel)

@tree.command(name="„Éû„ÉÉ„ÉÅÂ∏åÊúõÂèñ‰∏ã„Åí", description="„Éû„ÉÉ„ÉÅÂ∏åÊúõ„ÇíÂèñ„Çä‰∏ã„Åí„Åæ„ÅôÔºàËá™ÂàÜ„ÅÆ„ÅøÊúâÂäπÔºâ„ÄÇ")
async def cmd_cancel_wish(interaction: discord.Interaction):
    uid = interaction.user.id
    if uid not in hope_list:
        await interaction.response.send_message("„ÅÇ„Å™„Åü„ÅÆ„Éû„ÉÉ„ÉÅÂ∏åÊúõ„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
        return
    # cancel timer
    hope_list.pop(uid, None)
    t = hope_timers.pop(uid, None)
    if t and not t.done():
        t.cancel()
    await interaction.response.send_message("„Éû„ÉÉ„ÉÅÂ∏åÊúõ„ÇíÂèñ„Çä‰∏ã„Åí„Åæ„Åó„Åü„ÄÇ", ephemeral=True)

@tree.command(name="ÁµêÊûúÂ†±Âëä", description="ÔºàÂãùËÄÖÁî®ÔºâÂØæÊà¶ÁµêÊûú„ÇíÂ†±Âëä„Åó„Åæ„Åô„ÄÇÊïóËÄÖ„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
@app_commands.describe(opponent="ÊïóËÄÖ„ÅÆ„É°„É≥„Éê„Éº")
async def cmd_report_result(interaction: discord.Interaction, opponent: discord.Member):
    winner = interaction.user
    loser = opponent
    if not is_registered_match(winner.id, loser.id):
        await interaction.response.send_message("„Åì„ÅÆ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÅØÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åæ„Åö„ÅØ„Éû„ÉÉ„ÉÅÁî≥Ë´ã„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ", ephemeral=True)
        return
    # send approval view to channel (no DM)
    view = ResultApproveView(winner.id, loser.id)
    content = f"„Åì„ÅÆË©¶Âêà„ÅÆÂãùËÄÖ„ÅØ <@{winner.id}> „Åß„Åô„ÄÇÁµêÊûú„Å´ÂêåÊÑè„Åó„Åæ„Åô„ÅãÔºüÔºàÊâøË™çÔºöÂãùËÄÖ„ÅÆÁî≥Âëä„Å©„Åä„ÇäÔºèÁï∞Ë≠∞ÔºöÂØ©Âà§„Å∏Ôºâ"
    sent = await interaction.channel.send(content, view=view)
    # place entry in result_pending with auto-approve timer
    # We'll store channel so auto-approve can call handle_approved_result
    key = (winner.id, loser.id)
    # store info
    result_pending[key] = {"message": sent, "channel": interaction.channel}
    # immediate feedback to reporter
    await interaction.response.send_message("ÁµêÊûúÂ†±Âëä„ÇíÂèó„Åë‰ªò„Åë„Åæ„Åó„Åü„ÄÇÊïóËÄÖ„ÅÆÊâøË™ç„ÇíÂæÖ„Å°„Åæ„Åô„ÄÇ", ephemeral=True)
    # Start an auto-approve task: handled by ResultApproveView on_timeout using timeout above, so nothing more to do here.

@tree.command(name="„É©„É≥„Ç≠„É≥„Ç∞", description="ÁèæÂú®„ÅÆ„É©„É≥„Ç≠„É≥„Ç∞„ÇíË°®Á§∫„Åó„Åæ„ÅôÔºàÂÖ®„É¶„Éº„Ç∂„Éº‰ΩøÁî®ÂèØÔºâ„ÄÇ")
async def cmd_ranking(interaction: discord.Interaction):
    # Build ranking: sort by pt desc. Use standard competition ranking for ties.
    items = [(uid, user_data.get(uid, {}).get("pt", 0)) for uid in user_data.keys()]
    # ensure all guild members are included as needed
    # also include members in guild who might not yet be in user_data (default pt 0)
    guild = interaction.guild
    for m in guild.members:
        if m.bot:
            continue
        if m.id not in [x[0] for x in items]:
            items.append((m.id, get_user_pt(m.id)))
    # sort
    items.sort(key=lambda x: x[1], reverse=True)
    # standard competition ranking (1,2,2,4)
    ranking_lines = []
    last_score = None
    rank = 0
    display_rank = 0
    for uid, pt in items:
        rank += 1
        if pt != last_score:
            display_rank = rank
            last_score = pt
        # display simple username (use member.name to avoid duplicated icons)
        member = guild.get_member(uid)
        name = member.name if member else str(uid)
        role_name, icon = get_rank_info_by_pt(pt)
        ranking_lines.append(f"{display_rank}‰Ωç {name} {icon} {pt}pt")
    if not ranking_lines:
        await interaction.response.send_message("„É©„É≥„Ç≠„É≥„Ç∞„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
        return
    # send ephemeral to invoker with full list
    await interaction.response.send_message("\n".join(ranking_lines), ephemeral=True)

# ---------- ÁÆ°ÁêÜËÄÖ„Ç≥„Éû„É≥„ÉâÁæ§ (ADMIN_ID only) ----------

def is_admin(user: discord.User) -> bool:
    return user.id == ADMIN_ID

@tree.command(name="admin_set_pt", description="ÁÆ°ÁêÜËÄÖ: ÊåáÂÆö„É¶„Éº„Ç∂„Éº„ÅÆPT„ÇíË®≠ÂÆö„Åó„Åæ„ÅôÔºàÁÆ°ÁêÜËÄÖ„ÅÆ„ÅøÔºâ„ÄÇ")
@app_commands.describe(target="ÂØæË±°„ÅÆ„É°„É≥„Éê„Éº", pt="Ë®≠ÂÆö„Åô„ÇãptÔºàÊï¥Êï∞Ôºâ")
async def cmd_admin_set_pt(interaction: discord.Interaction, target: discord.Member, pt: int):
    if not is_admin(interaction.user):
        await interaction.response.send_message("„Åì„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÆ°ÁêÜËÄÖÂ∞ÇÁî®„Åß„Åô„ÄÇ", ephemeral=True)
        return
    if pt < 0:
        pt = 0
    set_user_pt(target.id, pt)
    # update display and roles across guilds
    for g in bot.guilds:
        await update_member_display(g, target.id)
    await interaction.response.send_message(f"{target.display_name} „ÅÆPT„Çí {pt} „Å´Ë®≠ÂÆö„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)

@tree.command(name="admin_reset_all", description="ÁÆ°ÁêÜËÄÖ: ÂÖ®„É¶„Éº„Ç∂„Éº„ÅÆPT„Å®Ë°®Á§∫„ÇíÂàùÊúüÂåñ„Åó„Åæ„ÅôÔºàÁÆ°ÁêÜËÄÖ„ÅÆ„ÅøÔºâ„ÄÇ")
async def cmd_admin_reset_all(interaction: discord.Interaction):
    if not is_admin(interaction.user):
        await interaction.response.send_message("„Åì„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÆ°ÁêÜËÄÖÂ∞ÇÁî®„Åß„Åô„ÄÇ", ephemeral=True)
        return
    user_data.clear()
    # reset nick/roles for all members in guilds
    for g in bot.guilds:
        for m in g.members:
            if m.bot:
                continue
            try:
                await safe_update_nick(m, None)
            except Exception:
                pass
            # remove rank roles
            try:
                rank_role_names = [r[2] for r in rank_definitions]
                to_remove = [r for r in g.roles if r.name in rank_role_names and r in m.roles]
                if to_remove:
                    await m.remove_roles(*to_remove, reason="Admin reset")
            except Exception:
                pass
    await interaction.response.send_message("ÂÖ®„É¶„Éº„Ç∂„Éº„ÅÆPT„Å®Ë°®Á§∫„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)

# ---------- Lifecycle: on_ready and command sync ----------

@bot.event
async def on_ready():
    logger.info(f"{datetime.utcnow().isoformat()} - {bot.user} is ready. Guilds: {[g.name for g in bot.guilds]}")
    # Sync commands to the specific guild for faster updates during development
    try:
        guild = discord.Object(id=GUILD_ID)
        await tree.sync(guild=guild)
        logger.info("Commands synced to guild.")
    except Exception as e:
        logger.exception("Failed to sync commands to guild: %s", e)

# ---------- Run ----------

if __name__ == "__main__":
    try:
        bot.run(TOKEN)
    except Exception as e:
        logger.exception("Bot raised an exception on run: %s", e)
